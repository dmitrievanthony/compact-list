package com.dmitrievanthony.clist;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import static org.objectweb.asm.Opcodes.BALOAD;
import static org.objectweb.asm.Opcodes.BASTORE;
import static org.objectweb.asm.Opcodes.CALOAD;
import static org.objectweb.asm.Opcodes.CASTORE;
import static org.objectweb.asm.Opcodes.DALOAD;
import static org.objectweb.asm.Opcodes.DASTORE;
import static org.objectweb.asm.Opcodes.FALOAD;
import static org.objectweb.asm.Opcodes.FASTORE;
import static org.objectweb.asm.Opcodes.IALOAD;
import static org.objectweb.asm.Opcodes.IASTORE;
import static org.objectweb.asm.Opcodes.LALOAD;
import static org.objectweb.asm.Opcodes.LASTORE;
import static org.objectweb.asm.Opcodes.SALOAD;
import static org.objectweb.asm.Opcodes.SASTORE;
import static org.objectweb.asm.Opcodes.T_BOOLEAN;
import static org.objectweb.asm.Opcodes.T_BYTE;
import static org.objectweb.asm.Opcodes.T_CHAR;
import static org.objectweb.asm.Opcodes.T_DOUBLE;
import static org.objectweb.asm.Opcodes.T_FLOAT;
import static org.objectweb.asm.Opcodes.T_INT;
import static org.objectweb.asm.Opcodes.T_LONG;
import static org.objectweb.asm.Opcodes.T_SHORT;

/**
 * The factory that produces instances of <tt>CompactList</tt>. Provides optimized implementations for primitives using
 * {@link CompactListGenerator}. For other types provides the default implementation {@link ObjectCompactList}.
 */
public class CompactListFactory {
    /** The class name prefix. */
    private static final String PREFIX = "com/dmitrievanthony/clist/";

    /** The class name suffix. */
    private static final String SUFFIX = "CompactList";

    /** The dynamic classloader. */
    private final DynamicClassLoader classLoader = new DynamicClassLoader();

    /** Cache for classes generated by {@link CompactListGenerator}. */
    private final Map<String, Class<?>> cache = new ConcurrentHashMap<>();

    /**
     * Constructs a new instance of <tt>CompactList</tt>. The implementation depends on the specified
     * <tt>elementType</tt>. For primitives (<tt>Byte</tt>, <tt>Character</tt>, <tt>Short</tt>, etc.) returns optimized
     * implementations based on {@link CompactListGenerator}. For other types provides the default implementation {@link
     * ObjectCompactList}.
     *
     * @param elementType the class of element in this list
     * @param <T> the type of elements in this list
     * @return the new instance of <tt>CompactList</tt>
     */
    public <T> CompactList<T> newCompactList(Class<T> elementType) {
        if (elementType.isPrimitive())
            return new ObjectCompactList<>();

        return getFromCacheOrGenerate(
            PREFIX.replace('/', '.') + elementType.getSimpleName() + SUFFIX,
            getCompactListGenerator(elementType)
        );
    }

    /**
     * Checks if the class for the specified <tt>elementType</tt> is already presented in the cache and returns it if
     * it's presented. Otherwise generates the new one, saves it into the cache and returns.
     *
     * @param className the class name
     * @param generator compact list generator
     * @param <T> the type of elements in this list
     * @return the instance of <tt>CompactList</tt>
     */
    private <T> CompactList<T> getFromCacheOrGenerate(String className, CompactListGenerator generator) {
        if (!cache.containsKey(className)) {
            synchronized (cache) {
                if (!cache.containsKey(className)) {
                    byte[] bytecode = generator.generate();
                    Class<?> clazz = classLoader.defineClass(className, bytecode);
                    cache.put(className, clazz);
                }
            }
        }

        Class<?> clazz = cache.get(className);

        return getNewInstance(clazz);
    }

    /**
     * Constructs the new instance of the specified class.
     *
     * @param clazz the class to be instantiated
     * @param <T> the type of elements in this list
     * @return the instance of <tt>CompactList</tt>
     */
    @SuppressWarnings("unchecked")
    private <T> CompactList<T> getNewInstance(Class<?> clazz) {
        try {
            return (CompactList<T>)clazz.newInstance();
        }
        catch (InstantiationException | IllegalAccessException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * Returns a <tt>CompactListGenerator</tt> specific for the specified <tt>elementType</tt>.
     *
     * @param elementType the class of element in this list
     * @param <T> the type of elements in this list
     * @return the instance of <tt>CompactListGenerator</tt>
     */
    private <T> CompactListGenerator getCompactListGenerator(Class<T> elementType) {
        if (Byte.class.equals(elementType))
            return getByteCompactListGenerator();
        else if (Character.class.equals(elementType))
            return getCharacterCompactListGenerator();
        else if (Short.class.equals(elementType))
            return getShortCompactListGenerator();
        else if (Integer.class.equals(elementType))
            return getIntegerCompactListGenerator();
        else if (Long.class.equals(elementType))
            return getLongCompactListGenerator();
        else if (Float.class.equals(elementType))
            return getFloatCompactListGenerator();
        else if (Double.class.equals(elementType))
            return getDoubleCompactListGenerator();
        else if (Boolean.class.equals(elementType))
            return getBooleanCompactListGenerator();

        throw new IllegalArgumentException("Specified type " + elementType + " is not a primitive");
    }

    /**
     * Returns <tt>CompactListGenerator</tt> that generates implementation of <tt>CompactList</tt> optimized to store
     * bytes.
     */
    private CompactListGenerator getByteCompactListGenerator() {
        return new CompactListGenerator(
            PREFIX + Byte.class.getSimpleName() + SUFFIX,
            "B",
            Byte.class.getCanonicalName().replace('.', '/'),
            "byteValue",
            T_BYTE,
            BASTORE,
            BALOAD
        );
    }

    /**
     * Returns <tt>CompactListGenerator</tt> that generates implementation of <tt>CompactList</tt> optimized to store
     * chars.
     */
    private CompactListGenerator getCharacterCompactListGenerator() {
        return new CompactListGenerator(
            PREFIX + Character.class.getSimpleName() + SUFFIX,
            "C",
            Character.class.getCanonicalName().replace('.', '/'),
            "charValue",
            T_CHAR,
            CASTORE,
            CALOAD
        );
    }

    /**
     * Returns <tt>CompactListGenerator</tt> that generates implementation of <tt>CompactList</tt> optimized to store
     * shorts.
     */
    private CompactListGenerator getShortCompactListGenerator() {
        return new CompactListGenerator(
            PREFIX + Short.class.getSimpleName() + SUFFIX,
            "S",
            Short.class.getCanonicalName().replace('.', '/'),
            "shortValue",
            T_SHORT,
            SASTORE,
            SALOAD
        );
    }

    /**
     * Returns <tt>CompactListGenerator</tt> that generates implementation of <tt>CompactList</tt> optimized to store
     * ints.
     */
    private CompactListGenerator getIntegerCompactListGenerator() {
        return new CompactListGenerator(
            PREFIX + Integer.class.getSimpleName() + SUFFIX,
            "I",
            Integer.class.getCanonicalName().replace('.', '/'),
            "intValue",
            T_INT,
            IASTORE,
            IALOAD
        );
    }

    /**
     * Returns <tt>CompactListGenerator</tt> that generates implementation of <tt>CompactList</tt> optimized to store
     * longs.
     */
    private CompactListGenerator getLongCompactListGenerator() {
        return new CompactListGenerator(
            PREFIX + Long.class.getSimpleName() + SUFFIX,
            "J",
            Long.class.getCanonicalName().replace('.', '/'),
            "longValue",
            T_LONG,
            LASTORE,
            LALOAD
        );
    }

    /**
     * Returns <tt>CompactListGenerator</tt> that generates implementation of <tt>CompactList</tt> optimized to store
     * floats.
     */
    private CompactListGenerator getFloatCompactListGenerator() {
        return new CompactListGenerator(
            PREFIX + Float.class.getSimpleName() + SUFFIX,
            "F",
            Float.class.getCanonicalName().replace('.', '/'),
            "floatValue",
            T_FLOAT,
            FASTORE,
            FALOAD
        );
    }

    /**
     * Returns <tt>CompactListGenerator</tt> that generates implementation of <tt>CompactList</tt> optimized to store
     * doubles.
     */
    private CompactListGenerator getDoubleCompactListGenerator() {
        return new CompactListGenerator(
            PREFIX + Double.class.getSimpleName() + SUFFIX,
            "D",
            Double.class.getCanonicalName().replace('.', '/'),
            "doubleValue",
            T_DOUBLE,
            DASTORE,
            DALOAD
        );
    }

    /**
     * Returns <tt>CompactListGenerator</tt> that generates implementation of <tt>CompactList</tt> optimized to store
     * booleans.
     */
    private CompactListGenerator getBooleanCompactListGenerator() {
        return new CompactListGenerator(
            PREFIX + Boolean.class.getSimpleName() + SUFFIX,
            "Z",
            Boolean.class.getCanonicalName().replace('.', '/'),
            "booleanValue",
            T_BOOLEAN,
            BASTORE,
            BALOAD
        );
    }
}
